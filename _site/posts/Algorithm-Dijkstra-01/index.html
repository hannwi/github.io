<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title> Dijkstra Algorithm</title><meta name="description" content="최단거리 문제알고리즘 문제를 풀다 보면, “어떤 점수의 최대값, 최소값 등을 구하시오.” 같은 문제를 본다.이 때 문제가 그래프로 모델링 가능하다면, 대부분 그래프의 최단거리를 계산함으로써 답을 구할 수 있다."><link rel="canonical" href="http://localhost:4000/posts/Algorithm-Dijkstra-01/"><link rel="alternate" type="application/rss+xml" title="Hannwi's Technical Blog" href="http://localhost:4000/feed.xml"><link href='https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|Roboto+Condensed:700&subset=latin' rel='stylesheet' type='text/css'><link rel="stylesheet" href="/assets/css/main.css"><meta property="og:url" content="http://localhost:4000/posts/Algorithm-Dijkstra-01/"><meta property="og:type" content="website"><meta property="og:title" content="Dijkstra Algorithm 01 (Intro)"><meta property="og:description" content="Study Dijkstra algorithm"><meta property="og:site_name" content="Hannwi's Technical Blog"><meta name="twitter:card" content="summary"><meta name="twitter:url" content="http://localhost:4000/posts/Algorithm-Dijkstra-01/"><meta name="twitter:title" content="Dijkstra Algorithm 01 (Intro)"><meta name="twitter:description" content="Study Dijkstra algorithm"><meta property="og:image" content="http://localhost:4000/assets/images/bg.svg"><meta name="twitter:image" content="http://localhost:4000/assets/images/bg.svg"><body><div id="shadow"></div><header class="main-header content-wrapper"> <input type="checkbox" id="menu-checkbox" /><nav class="center-wrapper nav-main"> <a class="blog-logo" href="/">Hannwi's Technical Blog</a> <a href="/about/">About</a> <a href="/posts/">Archive</a> <a href="/feed.xml">RSS</a> <label for="menu-checkbox" class="toggle-button" data-open="☰" data-close="☰" onclick></label></nav></header><aside class="sidebar" role="note" style="background-image: url(/assets/images/bg.svg)"><div class="cover"><div class="cover-text"><div class="heading"> <a href="/posts/#dijkstra">dijkstra</a></div><p> Study Dijkstra algorithm</div></div><div id="switcher"></div></aside><main class="content-wrapper"><article class="post"><h1 class="post-title">Dijkstra Algorithm 01 (Intro)</h1><p class="post-meta"> <time datetime="2020-02-11">11-02-2020</time> &nbsp;/&nbsp; <span>Hannwi</span><div class="post-content"><h3 id="최단거리-문제">최단거리 문제</h3><p>알고리즘 문제를 풀다 보면, “어떤 점수의 최대값, 최소값 등을 구하시오.” 같은 문제를 본다. 이 때 문제가 <code class="highlighter-rouge">그래프</code>로 모델링 가능하다면, 대부분 그래프의 최단거리를 계산함으로써 답을 구할 수 있다.<p>예시 문제: <a href="https://algospot.com/judge/problem/read/BOJ">알고스팟_BFS</a><h4 id="그래프graph란">그래프(Graph)란?</h4><p>그래프는 <code class="highlighter-rouge">정점(node)</code> 과 <code class="highlighter-rouge">간선(edge)</code>으로 이루어진 집합을 의미한다. 각 간선은 <code class="highlighter-rouge">가중치(weight)</code>를 가지고 있을 수 있으며, 가중치가 없을 때는 모든 간선이 1 의 가중치 값을 갖는다고 가정한다.<br /> 또한, 간선의 방향성 종류에 따라 두 가지로 그래프를 분류할 수 있는데, 간선에 방향성이 있으면 <code class="highlighter-rouge">방향 그래프(directed graph)</code>와, 방향성이 없으면 (양 방향으로 이동이 가능) <code class="highlighter-rouge">무방향 그래프(undirected graph)</code>라 부른다.<p align="center"> <img src="/assets/images/algorithm/dijkstra/undirected_graph.png" /><br /> <em>undirected graph with weighted edges</em><h4 id="그래프의-경로path와-거리distance">그래프의 경로(path)와 거리(distance)</h4><p>그래프의 특정 정점으로부터 특정 정점으로 이동하기 위해 지나가는 간선들의 집합을 <code class="highlighter-rouge">경로</code>라고 하자. 이 때, 경로의 가중치 합이 그 경로의 <code class="highlighter-rouge">거리</code>가 된다.<br /> 그래프의 <strong>최단거리</strong>란, 특정 시작 정점 s에서 출발하여 종료 정점으로 도착하기까지 지나는 모든 경로 중에서 가장 거리가 작은 경로의 거리 값을 의미한다.<p align="center"> <img width="400" src="/assets/images/algorithm/dijkstra/undirected_graph2_min_distance.png" /><br /> <em>minimum distances (red figures) from <strong>s</strong> to each node.</em><p>그래프의 최단거리를 구하는 알고리즘은 여러 가지가 존재하지만, 이 포스트에서는 그 중 가장 유명한(?) 다익스트라(Dijkstra) 알고리즘에 대해 공부한 내용을 정리해본다.<h3 id="다익스트라dijkstra-알고리즘">다익스트라(Dijkstra) 알고리즘</h3><h4 id="목적">목적</h4><p>다익스트라 알고리즘은 정해진 시작 정점 s로부터 <code class="highlighter-rouge">다른 모든 정점</code>까지의 최단거리를 구해주는 알고리즘이다.<br /> 그래서 시작점이 정해져 있는 문제에서 사용되며, 시작점이 정해져있지 않을 때는 다익스트라를 여러 번 실행해야 한다.<h4 id="개념">개념</h4><p>최단거리를 어떻게 구해야할까? 일단, 그래프의 노드를 방문하는 <code class="highlighter-rouge">탐색(traverse)</code>을 수행해야한다. <code class="highlighter-rouge">너비 우선 탐색(breadth first search)</code>이나 <code class="highlighter-rouge">깊이 우선 탐색(depth first search)</code>같은 탐색 방법에 대한 자세한 설명은 생략하겠다. 그리고, 탐색을 통해 노드를 방문할 때마다 그 노드까지의 거리를 저장할 수 있는 <code class="highlighter-rouge">버퍼</code>도 필요하다. 그렇다면, 노드를 방문하면서 시작점으로부터의 거리를 버퍼에 기록해나가면 최단 거리를 구할 수 있을까?<p>단순한 사고는 여기에서 문제점에 봉착한다. 임의의 탐색을 통해 노드를 방문하며 거리를 저장한다한들, 그 거리가 최단거리임을 어떻게 보장할 수 있을까? 아주 많은 횟수만큼 반복 방문을 수행하며 더 이상 거리가 더 작아지지 않을 때까지 탐색을 계속해야한다. 더구나, 탐색을 무한히 반복하지 않는 이상, 지금까지 구해놓은 각 노드까지의 거리가 해당 노드까지의 최단거리임을 확신할 수 없을 것이다.<p>다익스트라 알고리즘은, 이런 문제점을 해결하기 위해 <strong>greedy</strong> 한 접근법을 통해 최단거리를 찾는다. 즉, <em>“현 시점에서 최단거리임을 확신할 수 있는”</em> 노드를 <strong>우선적으로 방문</strong>하여 결과 버퍼를 채워나가며, <strong>모든 노드를 각 한 번 씩만 방문</strong>하고도 모든 노드의 최단거리를 구할 수 있는 알고리즘이다.<p>그렇다면 어떤 노드가 최단거리임을 확신할 수 있는 노드일까? 무조건 이보다 더 짧은 거리는 없다고 확신할 수 있는 노드는 무엇일까? 여기에 약간의 사고가 필요하다.<p>현재 노드에 간선으로 연결되어 있는 노드를 <code class="highlighter-rouge">인접 노드(adjacent node)</code>라 부른다. 인접 노드로 연결된 간선에는 저마다 가중치 값이 있고, 모든 가중치 값은 양수라고 가정해보자. 그렇다면 인접 간선 중 가장 작은 가중치 값을 갖는 간선은 최단거리를 만드는 경로라고 말할 수 있다. 예를 들어, 노드 <strong>s</strong>로부터 3 개의 간선이 다른 노드 <strong>a</strong>, <strong>b</strong>, <strong>c</strong>와 연결되어있고, 각 간선의 가중치 값이 1, 2, 3 이라고 할 때, <strong>s</strong>에서 <strong>a</strong>로 향하는 최단거리는 가장 작은 가중치 값인 1이 된다. 왜냐하면, 만약 <strong>a</strong>가 아닌 <strong>b</strong>나 <strong>c</strong>를 통해 <strong>a</strong>까지 가는 더 작은 거리가 있다고 한다면, 이는 1보다 더 작아야 한다. 그러나 이미 <strong>b</strong>나 <strong>c</strong>로 이동하는 순간 1 보다 거리가 커지며, 이후 어느 간선을 경유한다고 해도 음수 가중치는 없다고 전제하였으므로 거리는 1보다 작아질 수 없다. 따라서 인접한 간선 중 가장 작은 가중치 값을 가진 간선은 최단거리를 이루는 간선이라고 확신할 수 있다. 그러한 간선을 갖는 노드만 우선적으로 방문한다면, 노드 갯수에 비례하는 복잡도 내에서 최단거리를 계산할 수 있게 된다.<p>위의 greedy 개념을 이용하여 계산하는 것이 다익스트라 알고리즘이며, 많이들 사용되는 방법론을 다음 포스트에서 설명하도록 하겠다.<div class="post-links"> <a class="link-to-post" href="/posts/Algorithm-Dijkstra-02/"> <span class="link-to-post__next">&#10535; &nbsp;Next post</span> <span class="link-to-post__title">Dijkstra Algorithm 02 (Procdure)</span> </a> <a class="link-to-post" href="/posts/es6/"> <span class="link-to-post__prev">&#10535; &nbsp;Previous post</span> <span class="link-to-post__title">You Don't Know JS: ES6 & Beyond</span> </a></div></div></article></main><footer class="blog-footer content-wrapper"><p>&copy; <span class="full-year"></span> Hannwi's Technical Blog</footer><script src="/assets/js/scripts.js"></script>
